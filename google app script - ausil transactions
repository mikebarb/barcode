// Web App URL
// https://script.google.com/macros/s/AKfycbx_DqDOSn7YDqghfJWrbemoZadQn3i22e0oR62YzVMphBxlQeJc62QPkYpgNXmznn6A/exec

// Google Apps Script Code
// At the TOP of your script, define your spreadsheet ID
//const SPREADSHEET_ID = '1CbLT8fYvRl_avdpGiSXzTKyaEuSgV55f4ZXCTJv-aME'; // Your actual ID here
// FIXED: Use explicit spreadsheet ID
//const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
//const sheet = spreadsheet.getSheetByName('Transactions');
const headerNames = ["device id", "date - time", "sale type", "email", "name", "comment","ausid barcode", "quantity", "unit cost", "sub-total", "consignment", "description"];



function getSpreadsheetIdFromUrl(url) {
  var regex = /\/d\/([a-zA-Z0-9-_]+)/;
  var match = url.match(regex);
  return match ? match[1] : null;
}

function testLogging() {
  console.log("Test log message");
  Logger.log("Logger test message");
}

//=========================================//
// This is the web service                 //
// It is called from the mobile phone app  // 
// to upload and download spreadsheet data //
//=========================================//
function doGet(e) {
  // For JSONP, we use GET requests with parameters
  const callback      = e.parameter.callback;
  const spreadsheetId = e.parameter.spreadsheetid; 
  const sheetName     = e.parameter.sheet;
  const dataParam     = e.parameter.data;
  console.log("parameters: ", e.parameter);
  
  const spreadsheet = SpreadsheetApp.openById(spreadsheetId);
  const sheet = spreadsheet.getSheetByName(sheetName);
  
  try {
    let result;
      
    if (dataParam) {
      // This is an append request
      const postData = JSON.parse(dataParam);
      
      // Insert header if a new sheet.
      const isEmpty = sheet.getLastRow() === 0 && sheet.getLastColumn() === 0;
      if (isEmpty){
        sheet.appendRow(headerNames);
      }

      if (postData.rows && Array.isArray(postData.rows)) {
        postData.rows.forEach(row => {
          if (Array.isArray(row) && row.length > 0) {
            sheet.appendRow(row);
          }
        });
        console.log("rows appended");
        result = {
          success: true,
          message: `Appended ${postData.rows.length} rows`
        };
        
        // Add this to your doGet function after appending rows:
        const duplicatesRemoved = removeDuplicatesByColumns(sheet, [1, 6]); // Columns to check for duplicates

      } else {
        throw new Error('No valid rows data');
      }
    } else {
      // This is a read request
      const sheetData = sheet.getDataRange().getValues();
      result = {
        success: true,
        data: sheetData
      };
    }
    
    // Always return JSONP if callback provided
    if (callback) {
      return ContentService.createTextOutput(
        callback + '(' + JSON.stringify(result) + ')'
      ).setMimeType(ContentService.MimeType.JAVASCRIPT);
    } else {
      return ContentService.createTextOutput(
        JSON.stringify(result)
      ).setMimeType(ContentService.MimeType.JSON);
    }
    
  } catch (error) {
    const errorResult = {
      success: false,
      message: error.toString()
    };
    
    if (callback) {
      return ContentService.createTextOutput(
        callback + '(' + JSON.stringify(errorResult) + ')'
      ).setMimeType(ContentService.MimeType.JAVASCRIPT);
    } else {
      return ContentService.createTextOutput(
        JSON.stringify(errorResult)
      ).setMimeType(ContentService.MimeType.JSON);
    }
  }
}

// This is called at the end of uploading the sales transactions
// to ensure that duplicate transactions are removed.
function testRemoveDuplicates(){
  const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = spreadsheet.getSheetByName("transactions");
  removeDuplicatesByColumns(sheet, [0, 5]);
}

// And add this function to remove duplicates, based on indexed columns:
function removeDuplicatesByColumns(sheet, columnIndexes = [1, 6]) {
  console.log("removing duplicates");
  
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  
  const uniqueRows = new Set();
  const cleanedData = [headers];
  
  let duplicatesCount = 0;
  
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    // Create key from specified columns (e.g., col 0 = date, col 1 = barcode)
    const keyParts = columnIndexes.map(index => {
      const value = row[index];
      return value ? value.toString().trim() : '';
    });

    const rowKey = keyParts.join('|');
    
    if (!uniqueRows.has(rowKey)) {
      uniqueRows.add(rowKey);
      cleanedData.push(row);
    } else {
      duplicatesCount++;
    }
  }
  
  if (duplicatesCount > 0) {
    // Preserve formatting and formulas by only clearing content
    sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
    
    // Write back unique data (skip header row in write)
    if (cleanedData.length > 1) {
      sheet.getRange(2, 1, cleanedData.length - 1, cleanedData[0].length).setValues(cleanedData.slice(1));
    }
  }
  
  return duplicatesCount;
}

//==========================================================================//
// This set of functions processes the "transactions" in sheet transactions //
// and creates a set of sheets, each one used in the Ausil Office           //
// to update their inhouse system.                                          //
//==========================================================================//
function processData(){
  const spreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = spreadsheet.getSheetByName("transactions");
  const sheetData = sheet.getDataRange().getValues();

  // Need some ancilary data from the stock/taken list.
  const sheetTaken = spreadsheet.getSheetByName("taken");
  const sheetTakenData = sheetTaken.getDataRange().getValues();
  var takenConsignment = {};
  var takenDescription = {};
  sheetTakenData.forEach(entry =>{
    takenConsignment[entry[0]] = entry[3];
    takenDescription[entry[0]] = entry[1];
  });

  // Remove header
  sheetData.shift();                  // remove title row

  // Add ancillary data to each row for use in this function.
  sheetData.forEach(entry =>{
    var entryCode = entry[5];
    var entryConsignment = takenConsignment[entryCode] || "unknown";
    var entryDescription = takenDescription[entryCode] || "";
    entry.push(entryConsignment);
    entry.push(entryDescription);
  });

  // step through each transaction
  //var processCategories = ["ministry", "cash"];
  // Let's find all the categories from the sheet
  var processCategories = [];
  var processCategoryConsignment = {};
  sheetData.forEach(item =>{
    var itemCode = item[5];
    if (itemCode != "Discount") {
      var itemCategory = item[1];
      var itemConsignment = item[8];
      if (!processCategories.includes(itemCategory)) {
        processCategories.push(itemCategory);
        processCategoryConsignment[itemCategory] = [itemConsignment];
      }else{
        if(!processCategoryConsignment[itemCategory].includes(itemConsignment)){
          processCategoryConsignment[itemCategory].push(itemConsignment);
        }
      }
    }
  });
  //console.log("processCategories",processCategories);
  //console.log("processCategoryConsignment", processCategoryConsignment);

  // IN the Ausil office, PR and Ministy generate one invoice sheet each.
  // All the other categories are invoice by consignment within each category.
  
  // Diagnostics Only - copy of transaction sheet with consignment and description acded.
  // Delete old sheet and create a new one with headers.
  var sheetName1 = "copy_transaction";
  var processSheet1 = spreadsheet.getSheetByName(sheetName1);
  if (processSheet1){
    spreadsheet.deleteSheet(processSheet1);
  }
  processSheet1 = spreadsheet.insertSheet(sheetName1);
  processSheet1.appendRow(headerNames);    // add a header

  sheetData.forEach(entry =>{
      processSheet1.appendRow(entry);
  });

  // Underline this last row.
  var lastRow = processSheet1.getLastRow();
  var lastColumn = processSheet1.getLastColumn();
  if (lastRow > 0 && lastColumn > 0) {
    var lastRowRange = processSheet1.getRange(lastRow, 1, 1, lastColumn);
    // Add bottom border (underline)
    lastRowRange.setBorder(null, null, true, null, null, null, 'black', SpreadsheetApp.BorderStyle.SOLID);
  }

  // Now for the real processing - generating new sheets to match
  processCategories.forEach(processCategory => {
    var sheetName = "";
    if(processCategory == "ministry" || processCategory == "pr"){
      // just process this category without taking notice of consignments.
      sheetName = processCategory;
      processSheet(spreadsheet, sheetName, processCategory, "ANY", sheetData, takenConsignment, takenDescription, processSheet1);
    }else{
      // need to separate out consignments
      processCategoryConsignment[processCategory].forEach(thisConsignment=>{
        sheetName = processCategory + "_" + thisConsignment;
        processSheet(spreadsheet, sheetName, processCategory, thisConsignment, sheetData, takenConsignment, takenDescription, processSheet1);
      });
    }
  });
}

function processSheet(spreadsheet, sheetName, processCategory, processConsignment, sheetData, takenConsignment, takenDescription, processSheet1){
  //console.log("====================================================");
  //console.log("processCategory: " + processCategory + " processConsignment: " + processConsignment);
  //console.log("====================================================");    
  // Delete old sheet and create a new one with headers.
  var processSheet = spreadsheet.getSheetByName(sheetName);
  if (processSheet){
    spreadsheet.deleteSheet(processSheet);
  }
  processSheet = spreadsheet.insertSheet(sheetName);
  processSheet.appendRow(headerNames);    // add a header
  var total = 0;
  var items = {};
  var itemsValue = {};
  sheetData.forEach(entry =>{
    //console.log("entry: ", entry);
    var entryCode = entry[5];
    var entryConsignment = entry[8];
    var entryCategory = entry[1];
    var flagMatchConsignment = false;
    var flagMatchCategory = false;
    (entryCategory == processCategory) ? flagMatchCategory = true : false;
    ((entryConsignment && (entryConsignment == processConsignment)) || (processConsignment == "")) ? flagMatchConsignment = true : false;
    if (processConsignment == "ANY") flagMatchConsignment = true;
    //console.log("***itemCategory: " + entryCategory + " itemConsignment: " + entryConsignment);
    //console.log("flagMatchCategory: " + flagMatchCategory + " flagMatchConsignment: " + flagMatchConsignment);
    if(flagMatchCategory && flagMatchConsignment){
      //console.log("###itemCategory: " + entryCategory + " itemConsignment: " + entryConsignment);
      processSheet1.appendRow(entry);      // Diagnostics
      //console.log (processCategory, entry);
      var itemCode = entry[5];
      var itemQuantity = entry[6];
      var itemTotal = entry[7];
      if (items[itemCode]){
        items[itemCode] += itemQuantity;
        itemsValue[itemCode] = itemTotal;
      }else{
        items[itemCode] = itemQuantity;
        itemsValue[itemCode] = itemTotal;
      }
      processSheet.appendRow(entry);
      total = total + itemTotal;
    }
  });
  // Underline this last row.
  var lastRow = processSheet.getLastRow();
  var lastColumn = processSheet.getLastColumn();
  if (lastRow > 0 && lastColumn > 0) {
    var lastRowRange = processSheet.getRange(lastRow, 1, 1, lastColumn);
    // Add bottom border (underline)
    lastRowRange.setBorder(null, null, true, null, null, null, 'black', SpreadsheetApp.BorderStyle.SOLID);
  }
  // Attach summary details - the critical bit.
  for (const [key, value] of Object.entries(items).sort()) {
    // key = code, value = quantity of this item sold
    var itemTotal = value * itemsValue[key];
    processSheet.appendRow(["", "", "", "", "", key, value, itemTotal]);
  }
  processSheet.appendRow(["", "", "", "", "", "TOTAL", "", total]);
  formatSheet(processSheet);
  formatSheet(processSheet1);
}

function formatSheet(sheet){
  sheet.getRange('H:H').setNumberFormat('$#,##0.00');
  sheet.getRange('G:G').setHorizontalAlignment('center');
  sheet.getRange('I:I').setHorizontalAlignment('center');
  // Underline first row.
  //var lastRow = processSheet.getLastRow();
  var lastColumn = sheet.getLastColumn();
  if (lastColumn > 0) {
    var firstRowRange = sheet.getRange(1, 1, 1, lastColumn);
    // Add bottom border (underline)
    firstRowRange.setBorder(null, null, true, null, null, null, 'black', SpreadsheetApp.BorderStyle.SOLID);
    firstRowRange.setFontWeight('bold');
    for (var i = 1; i <= lastColumn; i++) {
      sheet.autoResizeColumn(i);
    }
  }
}

// Create a fresh spreadsheet
function createAndShareSpreadsheet() {
  var ss = SpreadsheetApp.create('Team Project');
  var url = ss.getUrl();
  // Share with specific email addresses
  ss.addEditor('robgordonclements1965@gmail.com');
  //ss.addViewer('manager@example.com');
  
  // Optional: Set sharing permissions
  DriveApp.getFileById(ss.getId())
    .setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
  
  console.log("url", url);
  var spreadsheetId = getSpreadsheetIdFromUrl(url); 
  console.log("spreadsheetId", spreadsheetId);  
  return url;
}



